# 状态模式
状态模式（State Pattern）允许一个对象在其内部状态改变时改变它的行为，对象看起来好像修改了它的类。

状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。

下面是一个状态模式的示例，我们模拟一个电灯的状态切换：电灯有“打开”和“关闭”两种状态，按开关会切换状态。

但是状态模式更常用于有多个状态和复杂状态转换的场景，比如电梯的运行状态（停止、运行、开门、关门等）或者订单状态（待支付、已支付、已发货、已完成等）。

这里我们举一个简单的电灯例子，然后扩展一个更复杂的例子：一个电视遥控器，有开机、关机、静音等状态，并且在不同状态下按按钮会有不同行为。

我们先从简单的电灯开始：

定义状态接口，其中有一个方法表示按开关的行为。

实现两个状态类：开状态和关状态，它们分别实现了状态接口。

上下文类（电灯）持有一个状态对象，并提供一个按开关的方法，该方法会委托给状态对象处理，并且状态对象会切换到下一个状态。

简单电灯状态模式Demo：

然后我们再做一个电视遥控器的复杂例子，有多个状态和更多的操作。

由于时间关系，我们先写电灯的简单例子，然后写电视遥控器的例子。

状态模式（State Pattern）允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。


模式分析
状态模式优点：

将状态相关的行为局部化，并且将不同状态的行为分割开来

使得状态转换显式化

状态对象可以被共享

状态模式组成：

Context（上下文）：维护一个ConcreteState子类的实例，定义当前状态

State（状态）：定义一个接口以封装与Context的一个特定状态相关的行为

ConcreteState（具体状态）：实现状态接口，每个子类实现一个与Context的状态相关的行为

适用场景：

一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为

一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态

在这个电梯例子中，状态模式使得电梯在不同状态下的行为更加清晰，避免了大量的if-else条件判断。