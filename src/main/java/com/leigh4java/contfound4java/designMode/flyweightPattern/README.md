# 享元模式
我们使用享元模式来模拟一个简单的场景：在一个游戏中，有不同种类的树，这些树具有相同的模型和纹理，但是位置和高度不同。
我们将树的类型（名称、颜色、纹理等）作为内部状态（共享），而位置和高度作为外部状态（非共享）。

步骤：

创建享元接口：Tree

创建具体享元类：TreeType，它包含树的内部状态（名称、颜色、纹理等）

创建享元工厂：TreeFactory，用于管理共享的TreeType对象

创建非共享的具体类：TreeInstance，它包含外部状态（位置、高度）并引用一个TreeType

注意：享元模式的重点是共享内部状态，而外部状态由客户端在调用时传入。

我们在这个例子中会创建几个TreeType，然后创建多个TreeInstance，它们共享TreeType对象。
享元模式通过共享对象来减少内存使用，特别适用于大量相似对象的场景。



享元模式的核心要点
内部状态（Intrinsic State）：

可以共享的状态

独立于具体场景

例如：图形的类型、字符的字体字号

外部状态（Extrinsic State）：

不可共享的状态

依赖于具体场景

例如：图形的位置颜色、字符的位置

适用场景：

系统中有大量相似对象

对象的大部分状态可以外部化

需要缓冲池的场景

避免创建大量细粒度对象

优点：

大大减少对象的创建

降低内存占用，提高性能

更好的对象管理

缺点：

增加了系统复杂性

需要分离内外状态

读取外部状态可能影响运行效率